###外观模式目的：
减少外部与系统内多个模块的交互，松散耦合，从而让外部能够更加简单的使用子系统。通俗点就是，外观模式就是对系统内部模块功能的一个包装，主要负责组合模块已有功能来实现客户的需要。
###使用外观模式与不适用的区别：
表面上，外观模式是将客户端调用服务的代码搬到了Facade中，实质上不一样的地方是，对服务端的调用从客户端，放到了服务端。因为Facade类存在于服务端。这就相当于屏蔽了
外部客户端和系统内部模块的交互，从而吧A、B、C模块组合为一个整体对外提供服务，。这样做的好处是：
1. 方便客户端的调用。
2. 封装了系统内部的实现细节。
3. 松散耦合。调用模块顺序发生了变化，客户端的代码不需要变动。
4. facade的代码可以被多个客户端共用，实现了代码复用。
5. 节省了学习成本，客户端只需要了解facade就可以。 

### 优缺点：
####优点：
- 松散耦合：
外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
- 简单易用：
 外观模式让子系统更加易用，客户端不需要关系子系统内部的实现，也不需要跟众多子系统内部模块进行交互，只需要跟外观交互就好了。
- 更好的划分访问的层次
通过合理使用Facade，可以帮助我们更好的划分访问的层次。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好的隐藏了内部的细节。
####缺点：
- 过多的、不太合理的Facade容易让人迷惑。
### 外观模式的本质：
封装交互，简化调用。
###设计原则的体现：
体现了“最少知道原则”。客户端只跟facade交互，对服务端具实现细节不关心。这样客户端会很简单，而且整个系统也更有弹性。服务端可以在不影响客户端的情况下，实现
系统内部的维护和扩展。
###外观模式使用场景：
- 为一个复杂子系统提供一个简单接口的时候。
- 想要让客户程序和抽象类的实现部分松散耦合，可以考虑外观模式。从而提高子系统的独立性和可移植性。
- 构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，可以简化层间调用，也可以松散层次之间的依赖关系。
