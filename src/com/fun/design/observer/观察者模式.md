# 观察者模式
## 定义
对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所以依赖于它的对象都得到通知并被自动更新。
## 观察者模式结构和说明
- Subject：目标对象，通常具有如下功能：
    - 一个目标可以被多个观察者观察。
    - 目标提供对观察者注册和退订的维护。
    - 当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者。
- Observer：定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，
可以在这个方法里面回调目标对象，以获取目标对象的数据。
- ConcreteSubject：具体的目标实现对象，用来维护目标状态，当目标对象的状态发生变化时，通知所有注册的、有效的观察者，
让观察者执行相应的处理。
- ConcreteObserver：观察者的具体实现对象，用来接收目标的通知，并进行相应的后续处理，比如更新自身的状态以保持和目标的相应状态一致。

## 认识观察者模式
### 目标和观察者之间的关系
按照模式定义，目标和观察者之间是一对多的关系。
但是，如果观察者只有一个也是可以的。这样就变相实现了目标和观察者之间一对一的关系，这也使得在处理一个对象的状态变化会影响到另一个对象的时候
也可以考虑使用观察者模式。
同样的，一个观察者也可以观察多个目标，若观察者为多个目标定义的通知方法是同一个方法的话，那就需要在方法内部区分到底来自于哪一个目标，不同
的目标有不同的后续操作。
  一般情况下，观察者应该为不同的目标对象定义不同的回调方法，这样可以通过方法名区分不同的目标回调。
### 单向依赖
观察者和目标是单向依赖的，只有观察者依赖于目标，而目标是不会依赖于观察者的。
他们之间的联系的主动权掌握在目标手中，只有目标知道什么时候需要通知观察者。在整个过程中，观察者始终是被动的，被动的等待目标的通知，
等待目标传值给他。
### 基本的实现说明
- 具体的目标实现对象要能维护观察者的注册信息，最简单的实现方案就是采用一个集合来保存观察者的注册信息。
- 具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自身的状态。变形使用的情况下，也可以是别的对象的状态。
- 具体的观察者实现对象需要能够接收目标的通知，能够接收目标传递的数据，或者能够主动去获取目标的数据，并进行后续处理。
- 如果一个观察者观察多个目标，那么观察者的更新方法里面，需要去判断是来自哪一个目标的通知。
### 命名建议
- 观察者模式又被称为发布--订阅模式。
- 目标接口的定义，建议在名称后面跟Subject。
- 观察者接口的定义，建议名称后面跟Observer。
- 观察者接口的更新方法，建议名称为update。
###触发通知的时机
一般情况下，是在完成了状态维护以后触发通知。不能先通知，后改状态，这样有可能会导致观察者和目标对象的状态不一致。

## 推模型和拉模型
观察者模式中又分为推模型和拉模型
- 推模型：
目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的消息通常是目标对象的全部或者部分数据，相当于是广播模式。
- 拉模型：
目标对象在通知观察者时，只传递少量信息。若观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。一般这种
模式中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。

### 两种模型对比
- 推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，
干脆把自身传给观察者，让观察者自己按需取值。
- 推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没考虑到的使用情况。这就意味着出现新情况的时候
可能需要提供新的update方法，或者重新实现观察者。而拉模型不会有这种情况，因为拉模型下，update方法获取的是目标对象本身，这基本上是目标对象
所能传递的最大数据集合了，基本上可以适应各种情况的需要。

## java中提供了观察者模式的类
java.util.Observable为目标类，实现了大部分我需要的目标的功能。
java.util.Observer为观察者接口。

## 优缺点：
### 优点：
- 实现了观察者和目标之间的抽象耦合。
原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，目标和观察者就只是在抽象层面上耦合了，也就是说
目标只是知道观察者接口，并不知道具体的观察者的类，从而实现目标类和具体观察者类之间解耦。
- 观察者模式实现了动态联动
所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态的控制注册的观察者，来控制
某个动作的联动范围，从而实现动态联动。
- 观察者模式支持广播通信
由于目标发送通知给观察者时面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然，也可以通过在目标上添加新的功能来
限制广播的范围。
###缺点
- 可能会引起无谓的操作
由于观察者模式每次都是广播通信，不管观察者需要不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，那么这次操作就浪费了。

##观察者模式本质：触发联动
当修改目标对象的状态的时候，会触发相应的通知，然后会通知所有注册的、有效的观察者。其实就相当于联动的调用这些观察者的方法。
## 适用场景：
- 当一个抽象模型有两个方面。其中一个方面的操作依赖于另一个方面的状态变化。
- 在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变。
- 当一个对象必须通知其他对象，但又希望这个对象和其他被通知的对象时松散耦合的。
