# 原型模式--prototype
## 定义
用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
## 原型模式解决问题的额思路
原型模式会要求对象实现一个可以“克隆”自身的接口，这样就可以通过拷贝或者是克隆一个实例对象本身来创建一个新的实例。
如果这个方法定义在接口上，看起来就像是通过接口来创建了新的接口对象。
## 原型模式结构
- Prototype:声明一个克隆自身的接口，用来约束想要克隆自己的类，要求它们都实现这里定义的克隆方法。
- ConcretePrototype:实现Prototype接口的类，这些类真正实现了克隆自身的功能。
- client:使用原型的客户端，首先要获取到原型实例对象，然后通过原型实例克隆自身来创建新的对象实例。
## 原型模式的功能
- 通过克隆来创建新的对象实例。
- 为克隆出来的新的对象实例复制原型实例属性的值。（此处可以复制一些不变的属性，例如类名，id等。也可以通过调用set方法，设置一些需要根据业务改变的值。）
## 原型与new的区别
原型模式是类似于new的操作。
区别在于：new一个实例对象，一般属性是没有值的，或者只有默认值。通过原型模式得到的实例，
通常属性是有值的，属性的值就是原型对象实例在克隆的时候，原型对象实例的属性的值。
## 原型实例和克隆的实例
原型实例和克隆出来的实例，本质上是不同的实例。
## 原型模式调用顺序
1. client创建实现了原型接口的对象的实例。
2. 调用克隆方法获取新的实例。
## java中的克隆方法
Object类提供了clone方法，需要克隆功能的类，只需要实现java.lang.Cloneable接口。这个接口没有需要实现的方法，只是一个标识接口。所以我们可以直接实现java中接口。
## 浅度克隆和深度克隆
- 浅度克隆：只负责克隆按值传递的数据（例如，基本数据类型、String类型）
- 深度克隆：除了浅度克隆的值以为，还负责克隆引用数据类型的数据。节本上就是被克隆实例所有的属性数据都会被克隆出来。
- 深度克隆还有一个特点，那就是被克隆对象里面的属性是引用类型，也就是说，属性的类型是个对象。那么需要一直递归的克隆下去。也就是说要想深度克隆成功，
那么所有克隆所涉及的对象都要正确实现克隆方法，如果其中一个没有正确的实现克隆，那么就会导致克隆失败。
**深度克隆中，不管是自己实现的clone方法还是Object类中的clone方法，被克隆对象中的引用类型的属性，必须显示的调用该属性类中的clone方法。**
## 原型模式的优点：
- 对客户端隐藏具体的实现类型
  原型模式的客户端只知道原型接口的类型，并不知道具体的实现类型，从而减少了客户端对这些具体实现类型的依赖。
- 在运行时动态改变具体的实现类型
  原型模式可以在运行期间，由客户来注册符合圆形接口的实现类型，也可以动态的改变具体的实现类型，看起来接口没有任何变化，但其实运行的是另一个实例。因为，克隆一个原型就类似于实例化一个类。
## 原型模式的缺点：
每个原型的子类都必须实现clone的操作，尤其在包含引用类型的对象时，clone方法比较麻烦，必须能够递归的让所有相关对象都正确的实现克隆。
## 原型模式的本质
克隆生成对象。克隆是手段，目的是生成新的对象实例。
## 使用场景
- 如果一个系统想要独立于它想要使用的对象时，可以使用原型模式，让系统只面向接口编程，在系统需要新的对象的时候，可以通过克隆原型来得到。
- 如果需要实例化的类是在运行时刻动态指定时，可以使用原型模式，通过克隆原型来得到需要的实例。