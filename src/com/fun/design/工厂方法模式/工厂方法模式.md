# 工厂方法模式的定义
用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

#使用工厂模式方法解决问题的思路：
- 先找到两个关键的接口
  - 被创建的product，即实际需要使用的对象的接口(或者抽象类)。
  - 创建器（creator），声明工厂方法。也就是包含工厂方法的接口(或者抽象类)。
- 创建接口的实现类。实现类个数可以根据需要创建。
- 客户端调用的时候，根据需要实例化具体的创建器子类。

# 工厂模式的功能：
让父类在不知道具体实现的情况下，完成自身的功能调用；而具体的实现延迟到子类来实现。

# 工厂方法实现类中的父类（creator）**_`****`_**
- 实现为抽象类
  工厂方法实现中，通常父类会是一个抽象类，里面包含创建所需对象的抽象方法，这些抽象方法就是工厂方法。
  **子类在实现这些抽象方法的时候，子类只是用来做选择，选择具体的产品实现对象。并不实现具体的功能。父类里面通常会有使用这些产品来实现一定功能的方法。而且这些方法
  所实现的功能通常是公共的功能。**
- 实现成具体的类
  - 父类也可以是一个具体的类。在这种情况下，通常是在父类中提供获取所需对象的默认实现方法，这样即使没有子类也能正常运行。
  - 这种情况通常也需要具体的子类来决定具体要创建的产品类的实现。
# 工厂方法创建的对象使用者
工厂方法模式里，工厂方法创建的对象时提供给creator里的其他方式使用的，不建议直接提供给creator外部的对象使用。
也就是说，客户端应该创建creator的对象，然后调用creator的方法，从间接调用product的功能。总之，在工厂方法模式中，客户端要么使用creator对象，要么使用creator创建的对象。一般不直接使用工厂方法。

# 工厂方法模式与IOC/DI
## 正确理解ioc与DI
- 参与者一般有三方：（参与者都有谁的问题）
  1. 任意的、普通的java对象
  2. IOC/DI容器，简单点儿说就是用来实现IOC/DI功能的一个框架程序。
  3. 外部资源。就是对象所需要的，但是得从对象外部获取的资源。例如，其他对象，或者文件资源等。
- 某个对象依赖于IOC/DI容器。（谁依赖谁的问题）
- 对象需要IOC/DI容器提供对象需要的外部资源。（为什么需要依赖的问题）
- IOC/DI容器注入某个对象。（谁注入于谁的问题）
- 注入某个对象所需的外部资源。（注入什么的问题）
- IOC/DI来控制对象。（谁控制谁的问题）
- 主要是控制对象实例的创建。（控制什么的问题）
- 正向的程序是，在对象中创建所需外部资源。这个是对象主动去获取的。反转说的是，对象不再主动获取外部资源，而是由IOC/DI获取外部资源，然后反向注入到对象中。对象是被动获取的。
- 依赖注入跟控制反转是对同一件事情的不同描述。依赖注入，从应用程序的角度出发：*应用程序依赖容器创建并注入它所需要的外部资源*；控制反转，从容器的角度描述：*容器控制应用程序，由容器反向的向应用程序注入所需要的外部资源。*

## 工厂方法模式与IOC/DI的关系
- IOC/DI模式：对象提供给容器注入的途径（可以为set方法注入、构造方法注入、接口注入）。然后直接调用外部资源即可。外部资源的创建交给容器。
- 工厂方法模式：对象要使用外部资源的时候，不需要对象去直接创建外部资源的实例，而是通过创建一个工厂方法，然后由该对象子类决定具体的外部资源实例，对象只需要调用方法即可。
所以他两在思想上是相似的，都是主动变被动，进行了主从换位。从而获得更灵活的程序结构。

# 工厂方法模式的优缺点：
## 优点：
- 可以在不知具体实现的情况下编程。
- 更容易扩展对象的新版本。
## 缺点：
具体产品对象和工厂方法的耦合性。

#工厂方法的使用场景：
- 如果一个类需要创建某个接口的对象，但是又不知道具体的实现。这种情况可以用工厂方法模式，将创建对象的工作延迟到子类中实现。
- 如果一个类本身就希望由他的子类来创建所需的对象的时候。