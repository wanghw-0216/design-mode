# 命令模式
## 定义
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
## 运用命令模式的思路
- 定义一个命令接口，用来约束所有的命令对象。
- 提供具体的命令实现，每个命令实现对象是对客户端某个请求的封装。
- 定义接收者对象来真正执行命令。
- 定义一个Client对象，用来装配命令对象和接收者对象之间的关系。
- 定义一个Invoker对象来持有命令对象。客户端通过Invoker对象来触发命令对象。

##示例代码中的结构说明
- Command：定义命令的接口，声明执行的方法。
- ConcreteCommand:命令接口实现对象；通常会持有接收者，调用接收者的功能来完成命令要执行的操作。所以它是一个"虚"实现。
- Receiver:接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要他能够实现命令要求实现的相应功能。
- Invoker:要求命令对象执行请求，通常会持有命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，相当于使用命令对象的入口。
- Client：创建具体的命令对象，并且设置命令对象接收者。这个不是常规意义的客户端，而是在组装命令对象和接收者。示例中，该client不仅是作为组装者，
还直接进行了Invoker的调用，相当于把client和invoker融合在一起了。可以把Invoker调用那部分提取出来，那么Client就可以做为一个纯粹的组装者。

## 认识命令模式
### 命令模式的关键
命令模式的关键是把请求封装成为对象，也就是命令对象。并定义了统一的执行操作的接口，这个命令对象可以被存储，转发，记录，处理，撤销等。
整个命令模式都围绕这个命令对象在进行。例如示例代码Client中，如果用户执行1号操作，那么就new一个ConcreteCommand对象，要执行2号操作就new
一个Concrete2Command对象。实际开发中，cleint和invoker是可以融合在一起的。
### 命令模式的组装和调用
命令模式中有一个命令的组装者（示例代码中的client），用它来维护命令的“虚”实现（既，command的子类）和真是实现（既示例代码中的Recevier）之间的关系。
真正的用户就是具体化请求的内容，然后提交请求进行触发。是通过Invoker来触发命令的。
如果命令对象自己实现了功能，那就不再需要接收者，自然也就不需要组装者了。
### 命令模式的接收者
接收者可以是任意的类。这个对象知道如何真正执行命令的操作，触发该执行操作是从Command的实现类里面转调过来的。
一个接收者可以处理多个命令， 接收者和命令之间没有约定的对应关系。接收者提供的方法个数、名称、功能和命令中的可以不一样，只要能够通过
调用接收者的方法来实现命令对应的功能就行。多个命令对象通过调用同一个接收者不同的方法达到实现逻辑的不一样。
### 智能命令
标准的命令模式中，命令的实现类是没有真正实现命令要求的功能的，只是通过调用接收者的方法来实现命令的功能。而智能命令是指，命令的实现类是有
自己的逻辑，是真实的实现了命令所要求的功能的，而不需要调用接收者来实现。半智能命令则是指，命令实现类实现了一部分命令要求的功能，剩下一部分
通过接收者来实现。
发起请求的对象（client）是不知道请求是由谁处理的，也不知道怎么处理的。他只管发出命令，其他的就不再管了。所以说，发起请求的对象和真正实现的
对象是解耦的。
## 参数化配置
### 定义：
可以用不同的命令对象，去7参数化配置客户的请求。即，客户的同一个请求，配置不同的命令实现对象，那么就会执行不同的功能。
##可撤销的操作
### 含义
放弃该操作，回到未执行该操作前的状态。GUI应用中的菜单就是命令模式最典型的应用之一。
### 如何实现：
- 补偿式又称为反操作式
例如，如果要撤销的操作是加的功能，那撤销的实现就是减的功能。
- 存储恢复式
就是把之前的状态记录下来，然后要撤销的时候，直接恢复回去就可以了。该方式就会涉及到备忘录模式。
##宏命令
###含义
包含多个命令的命令，是一个命令的组合。
###如何实现
其实就是在命令对象外面在包一层命令对象。该命令对象中，使用集合来存放需要使用到的命令对象，另外该命令对象中，还需要实现list中各个命令对象的
调用。这样就相当于一组命令。也就是宏命令。
## 队列请求
### 含义
所谓队列请求就是对命令对象进行排队，组成工作队列，然后依次取出命令对象来执行。通常用多线程来进行命令队列的处理。这样效率比较高。
##日志请求
### 含义
把请求的历史记录保存下来，一般是采用永久式存储的方式。如果系统运行过程中崩溃了，那么当系统再次运行时，可以从保存的历史记录中
获取日志请求，并重新执行命令。

##命令模式优点
- 更松散的耦合
命令模式使得发起命令的对象---客户端，和具体实现命令的对象---接收者对象完全解耦。
- 更动态的控制
命令模式把请求封装起来，可以动态的对它进行参数化，队列化和日志化等操作，从而使得系统更灵活。
- 很自然的复合命令
命令模式中的命令对象能够很容易的组合成复合命令，也就是上述宏命令。从而使得 系统操作更简单，功能更强大。
- 更好的扩展性
由于更松散的耦合，从而导致扩展新的命令很容易。

## 使用场景
- 如果需要抽象出需要执行的动作，并参数化这些对象。将需要执行的动作抽象成命令，然后实现命令的参数化配置。
- 如果需要在不同时刻指定、排列和执行请求。
- 如果需要支持取消操作。
- 如果需要支持当系统崩溃是，能将系统的操作功能重新执行 一遍。
- 需要事务的系统中。命令模式提供了对事务进行建模的方法。
