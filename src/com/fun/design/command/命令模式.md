#命令模式
## 定义
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
## 运用命令模式的思路
- 定义一个命令接口，用来约束所有的命令对象。
- 提供具体的命令实现，每个命令实现对象是对客户端某个请求的封装。
- 定义接收者对象来真正执行命令。
- 定义一个Client对象，用来装配命令对象和接收者对象之间的关系。
- 定义一个Invoker对象来持有命令对象。客户端通过Invoker对象来触发命令对象。

##示例代码中的结构说明
- Command：定义命令的接口，声明执行的方法。
- ConcreteCommand:命令接口实现对象；通常会持有接收者，调用接收者的功能来完成命令要执行的操作。所以它是一个"虚"实现。
- Receiver:接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要他能够实现命令要求实现的相应功能。
- Invoker:要求命令对象执行请求，通常会持有命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，相当于使用命令对象的入口。
- Client：创建具体的命令对象，并且设置命令对象接收者。这个不是常规意义的客户端，而是在组装命令对象和接收者。示例中，该client不仅是作为组装者，
还直接进行了Invoker的调用，相当于把client和invoker融合在一起了。可以把Invoker调用那部分提取出来，那么Client就可以做为一个纯粹的组装者。

## 认识命令模式
### 命令模式的关键
命令模式的关键是把请求封装成为对象，也就是命令对象。并定义了统一的执行操作的接口，这个命令对象可以被存储，转发，记录，处理，撤销等。
整个命令模式都围绕这个命令对象在进行。例如示例代码Client中，如果用户执行1号操作，那么就new一个ConcreteCommand对象，要执行2号操作就new
一个Concrete2Command对象。实际开发中，cleint和invoker是可以融合在一起的。
### 命令模式的组装和调用
命令模式中有一个命令的组装者（示例代码中的client），用它来维护命令的“虚”实现（既，command的子类）和真是实现（既示例代码中的Recevier）之间的关系。
真正的用户就是具体化请求的内容，然后提交请求进行触发。是通过Invoker来触发命令的。
如果命令对象自己实现了功能，那就不再需要接收者，自然也就不需要组装者了。
### 命令模式的接收者
接收者可以是任意的类。这个对象知道如何真正执行命令的操作，触发该执行操作是从Command的实现类里面转调过来的。
一个接收者可以处理多个命令， 接收者和命令之间没有约定的对应关系。接收者提供的方法个数、名称、功能和命令中的可以不一样，只要能够通过
调用接收者的方法来实现命令对应的功能就行。多个命令对象通过调用同一个接收者不同的方法达到实现逻辑的不一样。
### 智能命令
标准的命令模式中，命令的实现类是没有真正实现命令要求的功能的，只是通过调用接收者的方法来实现命令的功能。而智能命令是指，命令的实现类是有
自己的逻辑，是真实的实现了命令所要求的功能的，而不需要调用接收者来实现。半智能命令则是指，命令实现类实现了一部分命令要求的功能，剩下一部分
通过接收者来实现。
发起请求的对象（client）是不知道请求是由谁处理的，也不知道怎么处理的。他只管发出命令，其他的就不再管了。所以说，发起请求的对象和真正实现的
对象是解耦的。
## 参数化配置
### 定义：
可以用不同的命令对象，去7参数化配置客户的请求。即，客户的同一个请求，配置不同的命令实现对象，那么就会执行不同的功能。
##可撤销的操作
### 含义
放弃该操作，回到未执行该操作前的状态。GUI应用中的菜单就是命令模式最典型的应用之一。
### 如何实现：
- 补偿式又称为反操作式
例如，如果要撤销的操作是加的功能，那撤销的实现就是减的功能。
- 存储恢复式
就是把之前的状态记录下来，然后要撤销的时候，直接恢复回去就可以了。该方式就会涉及到备忘录模式。
##宏命令
###含义
包含多个命令的命令，是一个命令的组合。
###如何实现
