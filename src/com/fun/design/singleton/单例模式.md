#单例模式定义：
保证一个类仅有一个实例，并且提供一个访问它的全局访问点。
# 运用单例模式解决问题的思路：
- 首先，一个类能被创建多个实例，根本原因是，这个类的构造方法是公开的。所以，第一步，是需要类的构造方法私有化。
- 其次，要想控制一个类只被创建一个实例，那么就要把创建实例的权限收回，然后让类自身来负责自己类实例的创建工作，然后提供外部可以访问这个类实例的方法。

#单例模式的功能
用来保证某个类在运行期间只存在一个实例。

#单例模式的范围
对于java来说，单例的范围是一个虚拟机的范围。因为装载类的功能是虚拟机的。虚拟机通过自己的ClassLoader装在单例类的时候就会创建一个实例。
这意味着，如果一个虚拟机有多个classLoader，而且这些ClassLoader都装载某个类，那么即使这个类是单例，也会产生很多实例。当然，如果一个服务器有多个虚拟接，那么每个
虚拟机至少有一个这样的类。所以，此处的单例模式，不适用于集群模式。

#优缺点：
## 时间和空间
- 懒汉式，时间换空间。先判断，然后创建/返回实例。判断浪费时间，但是如果一直没人使用，则不会创建，节约空间。
- 饿汉式：空间换时间。类加载就会创建，不需要再判断，则节省时间。
## 线程安全
- 不加同步的懒汉式是线程不安全的。
- 饿汉式是线程安全的。

## 如何实现懒汉式的线程安全
- 加上synchronized。如下：
```java
    //性能比较低
    public static synchronized Singleton getInstance(){};
```
- 双重检查加锁。示例如（com.fun.design.singleton.lazy.DoubleLockSingleton)
这种方式性能比较高。只有在第一次创建实例的时候会执行同步块。以后不会再有同步。

# 单例的其他实现方式。
## 相关基础知识：
- 类级内部类：
  - 类级内部类：有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象及内部类。
  - 类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可以直接创建。而对象级内部类是绑定在外部对象的实例中的。
  - 类级内部类，可以定义静态的方法。在静态方法中只能引用外部类中的静态成员方法或者变量。
  - 类级内部类，相当于其外部类的成员，只有在第一次使用时才会被装载。
- 线程缺省同步锁：
    某些情况下，JVM隐含的执行了同步，这些情况下就不用自己来进行同步控制了。这些情况包括：
  - 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时。
  - 访问final字段时
  - 在创建线程之前创建对象时。
  - 线程可以看见它将要处理的对象时。


## 具体的实现方式：
- 静态内部类（类级内部类）实现
- 枚举实现
- 利用缓存实现单例
#具体代码示例：
git地址：
